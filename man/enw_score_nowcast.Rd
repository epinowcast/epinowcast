% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/model-validation.R
\name{enw_score_nowcast}
\alias{enw_score_nowcast}
\title{Evaluate nowcasts using proper scoring rules}
\usage{
enw_score_nowcast(
  nowcast,
  latest_obs,
  log = FALSE,
  check = FALSE,
  round_to = 3,
  ...
)
}
\arguments{
\item{nowcast}{A posterior nowcast or posterior prediction as returned by
\code{\link[=summary.epinowcast]{summary.epinowcast()}}, when used on the output of \code{\link[=epinowcast]{epinowcast()}}.}

\item{latest_obs}{A \code{data.frame} of the latest available observations as
produced by \code{\link[=enw_latest_data]{enw_latest_data()}} or otherwise.}

\item{log}{Logical, defaults to FALSE. Should scores be calculated on the
log scale (with a 0.01 shift) for both observations and nowcasts. Scoring in
this way can be thought of as a relative score vs the more usual absolute
measure. It may be useful when targets are on very different scales or when
the forecaster is more interested in good all round performance versus good
performance for targets with large values.}

\item{check}{Logical, defaults to FALSE. Should
\code{\link[scoringutils:check_forecasts]{scoringutils::check_forecasts()}} be used to check input nowcasts.}

\item{round_to}{Integer defaults to 3. Number of digits to round scoring
output to.}

\item{...}{
  Arguments passed on to \code{\link[scoringutils:score]{scoringutils::score}}
  \describe{
    \item{\code{data}}{A data.frame or data.table with the predictions and observations.
For examples, look at the \link[scoringutils]{example_quantile}, \link[scoringutils]{example_continuous},
\link[scoringutils]{example_integer}, and \link[scoringutils]{example_binary} data sets.
For scoring using \code{\link[scoringutils:score]{score()}}, the following columns need to be present:
\itemize{
\item \code{true_value} - the true observed values
\item \code{prediction} - predictions or predictive samples for one
true value. (You only don't need to provide a prediction column if
you want to score quantile forecasts in a wide range format.)}
For scoring integer and continuous forecasts a \code{sample} column is needed:
\itemize{
\item \code{sample} - an index to identify the predictive samples in the
prediction column generated by one model for one true value. Only
necessary for continuous and integer forecasts, not for
binary predictions.}
For scoring predictions in a quantile-format forecast you should provide
a column called \code{quantile}:
\itemize{
\item \code{quantile}: quantile to which the prediction corresponds
}}
    \item{\code{metrics}}{the metrics you want to have in the output. If \code{NULL} (the
default), all available metrics will be computed. For a list of available
metrics see \code{\link[scoringutils:available_metrics]{available_metrics()}}, or check the \link[scoringutils]{metrics} data set.}
  }}
}
\value{
A \code{data.table} as returned by \code{\link[scoringutils:score]{scoringutils::score()}}.
}
\description{
Acts as a wrapper to \code{\link[scoringutils:score]{scoringutils::score()}}. In particular,
handling filtering nowcast summary output and linking this output to
observed data. See the documentation for the \code{scoringutils} package for more
on forecast scoring.
}
\examples{
\dontshow{if (interactive()) (if (getRversion() >= "3.4") withAutoprint else force)(\{ # examplesIf}
library(data.table)
library(scoringutils)

# Summarise example nowcast
nowcast <- enw_example("nowcast")
summarised_nowcast <- summary(nowcast)

# Load latest available observations
obs <- enw_example("observations")

# Keep the last 7 days of data
obs <- obs[reference_date > (max(reference_date) - 7)]

# score on the absolute scale
scores <- enw_score_nowcast(summarised_nowcast, obs)
summarise_scores(scores, by = "location")

# score overall on a log scale
log_scores <- enw_score_nowcast(summarised_nowcast, obs, log = TRUE)
summarise_scores(log_scores, by = "location")
\dontshow{\}) # examplesIf}
}
\concept{modelvalidation}
