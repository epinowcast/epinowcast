---
title: "Estimating the effective reproduction number in real-time: A case study using synthetic data and hospital admissions data from the COVID-19 pandemic in Germany"
description: ""
author: Sam Abbott
opengraph:
  image: 
    src: figures/performance-1.png
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Estimating the effective reproduction number in real-time: A case study using synthetic data and hospital admissions data from the COVID-19 pandemic in Germany}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>", 
  eval = FALSE
)
```

# Outline

- Introduce the package and sign post to further documentation
- Introduce the problem targeted in this vignette (Rt estimation by date of infection where observed cases are right truncated due to reporting delays). 


In this report we make use of
[epinowcast](https://epiforecasts.io/epinowcast/), a nowcasting package
under development and designed from the ground up around nowcasting with
the aim of replacing [EpiNow2](https://epiforecasts.io/EpiNow2/) for
real-time usage. We first explore the data using tools from `epinowcast`
alongside others. We then nowcast the latest available data, visualise
our results, and discuss potential options for improving performance on
real-world data. As a check of our approach we construct some
retrospective data, nowcast it, and compare our nowcast to the latest
available data. We then extract the estimated delay distribution and
compare it to the underlying distribution used to generate the data, the
empirical distribution, and the distribution estimated using simpler
methods. Finally, we show how the output from `epinowcast` may be used
in other surveillance packages such as `EpiNow2`. Throughout this case
study we discuss potential issues with the approaches taken, and
highlight areas for futher work. For more on `epinowcast` and itâ€™s
planned development roadmap see [the package
documentation](https://epiforecasts.io/epinowcast/). An [alternative
approach](epinow2.md) to the problem using `EpiNow2`, suffering from
some limitations that `epinowcast` is aiming to address, is also
available in this repository.


Tools to enable flexible and efficient hierarchical nowcasting of right-truncated epidemiological time-series using a semi-mechanistic Bayesian model with support for a range of reporting and generative processes. Nowcasting, in this context, is gaining situational awareness using currently available observations and the reporting patterns of historical observations. This can be useful when tracking the spread of infectious disease in real-time: without nowcasting, changes in trends can be obfuscated by partial reporting or their detection may be delayed due to the use of simpler methods like truncation. While the package has been designed with epidemiological applications in mind, it could be applied to any set of right-truncated time-series count data.


# Getting setup

See the [package documentation](https://epiforecasts.io/epinowcast/) for guidance on installing the package and getting setup with `cmdstanr` (the backend used for fitting models). 

As well as the `epinowcast` package we will use the following packages in this vignette.

```{r setup}
library(epinowcast)
# Here we use data.table for simple data transforms but tools from the tidyverse
# or base R tools could just as easily be used.
library(data.table) 
library(ggplot2)
```

# Introducing the case study data: COVID-19 hospitalisations in Germany

- Germany hospitalisations
- Introduce the data
- Explain why we are using it here. Reference the Germany nowcasting preprint.
- Graph data (or use a graph from the Germany nowcasting preprint)

# Model

## Expected hospitalisations

In settings where data is sparse or where users want to understand the underlying generative process our flexible default model is likely not a good choice. In these settings our generic model offers a range of options that are context specific. Our generic model is currently based on a renewal process [@Fraser2007; @Cori2013] with additional latent reporting delays [@EpiNow2; @Abbott2020; @Bhatt2020]. As previously noted [@champredon], this corresponds to the commonly used Susceptible-Exposed-Infected-Recovered (SEIR) model when appropriate generation time is specified [@champredon]

### Instantaneous reproduction number

We model the instantaneous reproduction number ($R_t$) on the log scale as a weekly random walk as follows

\begin{align}
  \text{log} (R_{t}) &= r_0 + \sum_{i = 0}^{t \% 7} \epsilon_i \\
  \epsilon_i &\sim \text{Normal}\left(0, \sigma_{\epsilon} \right) \\
  \sigma_{\epsilon} &\sim \text{HalfNormal}\left(0, 1 \right)
\end{align}

where $r_0$ is the intercept, and $\sum_{i = 0}^{t \% 7} \epsilon_i$ is a weekly random walk.

### Latent infections

We model the expected number of infections/latent notifications ($\lambda^l$) using a renewal process [@Fraser2007; @Cori2013]. This model is a generalisation of the default model and can be used to model the expected number of latent notifications in a setting where the generation time is not fixed to be a day. It implies that current infections/notifications are dependent on past infections/notifications based on a kernel (usually interpreted as the generation time or serial interval). An instantaneous daily growth rate model can be recovered by setting the generation time to be fixed at 1 day. The model is defined as follows,

\begin{align}
  \lambda^l_{t} &\sim \text{LogNormal}\left(\mu^{l}, \sigma^{l} \right),\ t \leq P \\
  \lambda^l_{t} &= R_{t} \sum_{p = 1}^{P} g\left(t - p \right)  \lambda^l_{t-p},\ t \gt P  
\end{align}

## Latent reporting delay and ascertainment

In some settings there may be additional reporting delays on top of those that are directly observed in the data, and therefore "nowcastable", a common example is the delay from exposure to symptom onset. For these settings we support modelling "latent" reporting delays as a convolution of the underlying expected counts with the potential for these delays to vary over time and by group. This implementation is similar to that implemented in `EpiNow2` and `epidemia` as well as other similar models  [@EpiNow2; @Abbott2020; @Bhatt2020; @Lison2022]. In addition to this we support modelling ascertainment through the use of improper probability mass functions (i.e. by not enforcing a sum to 1 constraint) and inferring ascertainment where possible (for example day of the week reporting patterns).

\begin{align}
  \lambda_{t} &= \nu_{t \% 7} \sum_{\tau = 0}^{L - 1} f_{g}\left(t - \tau \right)  \lambda^l_{t - \tau} \\
  \text{log} (\nu_{i}) &\sim \text{Normal}\left(0, \sigma_{\nu} \right) \\
  \sigma_{\nu} &\sim \text{HalfNormal}\left(0, 1 \right) \\
\end{align}

Where $\nu_{i}$ is a random effect for each day of the week which represents reporting periodicity.

## Specifying the model using `epinowcast::enw_expectation()`

```{r expected-infections}
expectation_module <- purrr::partial(
  epinowcast::enw_expectation,
  r = ~ 1 + rw(week),
  generation_time = c(0.1, 0.4, 0.4, 0.1),
  observation = ~ (1 | day_of_week),
  latent_reporting_delay = c(0.05, 0.3, 0.6, 0.05)
))
```

## Delay distribution

Given case counts both by date of reference and by date of report, we can estimate the reporting delay distribution directly and jointly with the underlying process model, rather than relying on external estimates from other sources (though we may want to account for external information in our priors). In the following section, we describe our default parametric delay distribution model and its extension into a generic, highly flexible delay model based on discrete time-to-event modelling.

We consider the reporting delay to follow a $\text{LogNormal} \left(\mu^d, \sigma^d \right)$ distribution, with parameters

\begin{align}
  \mu^d &\sim \text{Normal} \left(0, 1 \right) \\
  \sigma^d &\sim \text{Half-Normal} \left(0, 1 \right).
\end{align}

This distribution is discretised into daily probabilities $p_{t,d}$ and adjusted for the maximum delay, see `vignette("distributions")` for details.

## Observation model and nowcast

Expected notifications by date of hospitalisations ($t$) and reporting date can now be found by multiplying expected final notifications for each $t$ with the probability of reporting for each day of delay ($p_{t,d}$). We assume a Poisson observation model and produce a nowcast of final observed hospitalisations at each reference date by summing posterior estimates for unobserved notification and observed notifications for that reference date.

\begin{align}
  n_{t,d} \mid \lambda_{t},p_{t,d}  &\sim \text{Poisson} \left(\lambda_{t} \times p_{t,d),\ t=1,...,T. \\
  N_{g,t} &= \sum_{d=0}^{D} n_{g,t,d}
\end{align}

# Simulated data to evaluate the model

## Simulating the data

- Rt trajectory with a change point and a trend
- Specify a gamma distributed generation time.
- Use the renewal equaton to simulate cases (uu)
- Specify a delay from infection to hospitalisation.
- Specify a day of the week reporting model.
- Specify a reporting fraction.
- Convolve the reporting delay with the underlying cases to get expected hospitalisations.
- Add noise to the expected hospitalisations to get observed hospitalisations
- Specify a lognormal reporting delay model.
- Project the observed hospitalisations using the reporting delay into a linelist.

## Preprocessing the simulated data

```{r, eval = FALSE}
synth_obs <- linelist_to_obs(synth_linelist)

# Make a retrospective dataset
retro_synth_obs <- synth_obs |>
  # Remove the last 40 days of reproted data
  enw_filter_report_dates(remove_days = 40) |>
  # INlcude on refernece dates within the last 40 days
  enw_filter_reference_dates(include_days = 40)

# Get latest observations for the same time period
latest_synth_obs <- enw_latest_data(synth_obs) |>
  enw_filter_reference_dates(remove_days = 40, include_days = 40)

# Preprocess observations
synth_pobs <- enw_preprocess_data(retro_synth_obs, max_delay = 30)
germany_pobs
```

## Visualising the simulated data


## Fit the `epinowcast` model

Fit nowcast model with the pre-specified modules and produce a nowcast

```{r}
synth_nowcast <- epinowcast(synth_pobs,
  expectation = expectation_module(data = synth_pobs),
  reference = reference_module(data = synth_pobs),
  report = report_module(data =synth_pobs),
  fit = fit_module(),
  model = model
)
```

## Plot the nowcast against observed data

```{r plot-synth-nowcast
plot(synth_nowcast, latest_obs)
```

## Plot the effective reproduction number

```{r plot-synth-rt}
rt <- synth_nowcast$fit[[1]] |>
  enw_posterior(variables = "r")
cols <- c("mean", "median", "q5", "q20", "q80", "q95")
rt[, (cols) := lapply(.SD, exp), .SDcols = cols]
rt <- cbind(
  expectation_module(data = synth_pobs)$data_raw$r[, .(date)], rt
)

ggplot(rt) +
  aes(x = date) +
  geom_line(aes(y = median), linewidth = 1, alpha = 0.6) +
  geom_line(aes(y = mean), linetype = 2) +
  geom_ribbon(aes(ymin = q5, ymax = q95), alpha = 0.2, linewidth = 0.2) +
  geom_ribbon(aes(ymin = q20, ymax = q80, col = NULL), alpha = 0.2) +
  geom_hline(yintercept = 1, linetype = 2) +
  theme_bw() +
  labs(
    x = "Reference date",
    y = "Effective reproduction number"
  )
```

## Plot the posterior distribution of the reporting delay

```{r plot-germany-delay}
```

## Plot the posterior distribution of the day of the week reporting model

# Fitting the model to COVID-19 hospitalisations in Germany

## Preprocess the data

```{r}
# Load and filter germany hospitalisations
germany_hosp <- germany_covid19_hosp[
  location == "DE"][age_group %in% "00+"] |>
  enw_filter_report_dates(latest_date = "2021-08-01")
  # Make sure observations are complete
  enw_complete_dates()

# Make a retrospective dataset
retro_germany <- germany_hosp |>
  # Remove the last 40 days of reproted data
  enw_filter_report_dates(remove_days = 40) |>
  # INlcude on refernece dates within the last 40 days
  enw_filter_reference_dates(include_days = 40)

# Get latest observations for the same time period
latest_obs <- enw_latest_data(germany_hosp) |>
  enw_filter_reference_dates(remove_days = 40, include_days = 40)

# Preprocess observations
germany_pobs <- enw_preprocess_data(retro_nat_germany, max_delay = 30)
germany_pobs
```


## Fit the `epinowcast` model

```{r}
# Fit nowcast model with these modules and produce a nowcast
germany_nowcast <- epinowcast(germany_pobs,
  expectation = expectation_module(data = germany_pobs),
  reference = reference_module(data = germany_pobs),
  report = report_module(data = germany_pobs),
  fit = fit_module(),
  model = model
)
```

## Plot the nowcast against observed data

```{r plot-germany-nowcast
plot(germany_nowcast, latest_obs)
```

## Plot the effective reproduction number

```{r plot-germany-rt}
rt <- germany_nowcast$fit[[1]] |>
  enw_posterior(variables = "r")
cols <- c("mean", "median", "q5", "q20", "q80", "q95")
rt[, (cols) := lapply(.SD, exp), .SDcols = cols]
rt <- cbind(
  expectation_module(data = germany_pobs)$data_raw$r[, .(date)], rt
)

ggplot(rt) +
  aes(x = date) +
  geom_line(aes(y = median), linewidth = 1, alpha = 0.6) +
  geom_line(aes(y = mean), linetype = 2) +
  geom_ribbon(aes(ymin = q5, ymax = q95), alpha = 0.2, linewidth = 0.2) +
  geom_ribbon(aes(ymin = q20, ymax = q80, col = NULL), alpha = 0.2) +
  geom_hline(yintercept = 1, linetype = 2) +
  theme_bw() +
  labs(
    x = "Reference date",
    y = "Effective reproduction number"
  )
```

## Plot expected latent cases

```{r plot-germany-latent-cases}
latent_exp_cases <- enw_posterior(
  germany_nowcast$fit[[1]],
  variables = "exp_llatent"
)
latent_exp_cases[, (cols) := lapply(.SD, exp), .SDcols = cols]
latent_exp_cases <- cbind(
  enw_extend_date(
    expectation_module(data = germany_pobs)$data_raw$r[, .(date, .group = 1)],
    days = germany_nowcast$data[[1]]$expl_lrd_n,
    direction = "start"
  ),
  latent_exp_cases
)

ggplot(latent_exp_cases) +
  aes(x = date) +
  geom_line(aes(y = median), linewidth = 1, alpha = 0.6) +
  geom_line(aes(y = mean), linetype = 2) +
  geom_ribbon(aes(ymin = q5, ymax = q95), alpha = 0.2, linewidth = 0.2) +
  geom_ribbon(aes(ymin = q20, ymax = q80, col = NULL), alpha = 0.2) +
  theme_bw() +
  labs(
    x = "Reference date",
    y = "Expected latent cases"
  )
```

## Plot expected reported cases

```{r plot-germany-reported-cases}
exp_cases <- enw_posterior(
  germany_nowcast$fit[[1]],
  variables = "exp_lobs"
)
exp_cases[, (cols) := lapply(.SD, exp), .SDcols = cols]
exp_cases <- cbind(
  expectation_module$data_raw$observation,
  exp_cases
)

exp_cases <- enw_latest_data(germany_hosp)[, date := reference_date][
  exp_cases,
  on = "date"
]

ggplot(exp_cases) +
  aes(x = date) +
  geom_point(aes(y = confirm)) +
  geom_line(aes(y = median), linewidth = 1, alpha = 0.6) +
  geom_line(aes(y = mean), linetype = 2) +
  geom_ribbon(aes(ymin = q5, ymax = q95), alpha = 0.2, linewidth = 0.2) +
  geom_ribbon(aes(ymin = q20, ymax = q80, col = NULL), alpha = 0.2) +
  theme_bw() +
  labs(
    x = "Reference date",
    y = "Expected reported cases"
  )
```

# Discussion

## Summary

## Strengths

- We have used a single model to estimate the effective reproduction number and the expected number of latent and reported cases from right truncated data. This means that we have propogated uncertainty from the estimation of the effective reproduction number into the estimation of the expected number of latent and reported cases which would be difficult using a mulit-stage approach.

## Limitations

- Assumed a known and static generation time distribution and latent reporting delay distribution. In reality these would need to be estimated from data, have uncertainty, and be liable to change over time.
- Used a fixed parametric reporting delay distribution. In reality this would likely vary over time and depend on things like day of the week reporting effects. This could be addressed by using a more flexible reporting delay distribution which is supported by `epinowcast`.

## Alternative models

- `EpiNow2`:
- `EpiEstim`:
- `epidemia`:

## Further work

- Use a more flexible reporting delay distribution.
- Use a more flexible generation time distribution.
- Use a more flexible model for the effective reproduction number.
- Add functionality to allow forecasting beyond the horizon of the observed data.

## Conclusions

# References